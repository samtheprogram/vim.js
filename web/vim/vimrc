" Tinmarino's vimrc for vim.js

silent exec '!console.log("tinp: vimrc 4")'

" Javascript wrap
function! ReadDoc(file)
    " Function to load a file in mem

  	" Get current path/file
	if (a:file[0] == "/")
	  let l:path = "".join(split(a:file, "/")[:-2], "/")
	  let l:file = split(a:file, "/")[-1] 
	else
	  let l:path = expand("%:p:h")
	  let l:file = a:file
	endif

  	" Load file
	let l:cmd =  '!tin_load("' .l:path."/".l:file . '")' 

	" Edit file 
	let l:file_path = "/" . l:path . "/" . l:file
    execute  l:cmd
	execute "edit"  l:file_path

	" Debug regs
	let @a=l:cmd
	let @b=l:file_path
	let @c=l:path
	let @d=a:file
endfunction

function! ReadWrapper(word)
  let l:file = substitute(a:word, "|", "", "g")
  silent call ReadDoc(l:file)
endfunction

function! OpenXref(link)
	let l:cmd =  "!tin_href('" . a:link . "', '<-vim.js');"
    execute l:cmd
endfunction

function! DownloadFile()
    " Download buffer content with filename
    let l:filename = expand("%:t")
    let l:content = join(getline(1,'$'), "<tincr>")
    let l:content = substitute(l:content, "'", "<tinq1>", 'g')
    let l:content = substitute(l:content, "\\", "<tinbs>", 'g')
    let l:cmd = "!tin_download('" . l:filename. "', '" . l:content . "');"
    silent execute l:cmd
endfunction

" Pluggin dit
let g:d_plugin = {}
"AnsiEscape
let g:d_plugin["ansiesc"] = ["https://github.com/powerman/vim-plugin-AnsiEsc"]
call add(g:d_plugin["ansiesc"], "plugin/AnsiEscPlugin.vim")
call add(g:d_plugin["ansiesc"], "autoload/AnsiEsc.vim")
call add(g:d_plugin["ansiesc"], "plugin/cecutil.vim")

let g:d_plugin["airline"] = ["https://github.com/vim-airline/vim-airline"]
call add(g:d_plugin["airline"], "plugin/airline.vim")
call add(g:d_plugin["airline"], "autoload/airline.vim")

call add(g:d_plugin["airline"], "autoload/airline/section.vim")
call add(g:d_plugin["airline"], "autoload/airline/async.vim")
call add(g:d_plugin["airline"], "autoload/airline/util.vim")
call add(g:d_plugin["airline"], "autoload/airline/parts.vim")
call add(g:d_plugin["airline"], "autoload/airline/themes.vim")
call add(g:d_plugin["airline"], "autoload/airline/themes")
call add(g:d_plugin["airline"], "autoload/airline/highlighter.vim")
call add(g:d_plugin["airline"], "autoload/airline/msdos.vim")
call add(g:d_plugin["airline"], "autoload/airline/debug.vim")
call add(g:d_plugin["airline"], "autoload/airline/extensions.vim")
call add(g:d_plugin["airline"], "autoload/airline/builder.vim")
call add(g:d_plugin["airline"], "autoload/airline/init.vim")

call add(g:d_plugin["airline"], "autoload/airline/themes/dark.vim")
call add(g:d_plugin["airline"], "autoload/airline/extensions/default.vim")

let g:d_plugin["ctrlp"] = "https://github.com/kien/ctrlp.vim"
let g:d_plugin["surround"] = "https://github.com/tpope/vim-surround"
let g:d_plugin["nerdtree"] = "https://github.com/scrooloose/nerdtree"
let g:d_plugin["none"] = "nothing"

function! LoadPlugin(name)
    " Load plugin if name in a list
    echom "Loading Plugin: " . a:name
    let l:index = index(keys(g:d_plugin), a:name)
    if (index == -1) | ret | endif

    " Let path
    let l:out_path = '/vim/plugin/' . a:name . "/"

    " Create dir
    let l:cmd = '!Module["FS_createPath"]("/vim/plugin", "'
    let l:cmd .= a:name . '", true, true);'
    echom "Cmd1: " . l:cmd
    silent execute l:cmd
    let l:cmd_p = '!Module["FS_createPath"]("/vim/plugin/' . a:name . '", '
    let l:cmd_p .= '"plugin", true, true);'
    echom "Cmdp: " . l:cmd_p
    silent execute l:cmd_p
    let l:cmd_a = '!Module["FS_createPath"]("/vim/plugin/' . a:name . '", '
    let l:cmd_a .= '"autoload", true, true);'
    echom "Cmda: " . l:cmd_a
    silent execute l:cmd_a
    

    " Download Raw files
    let l:d_list = g:d_plugin[a:name]
    let l:url = l:d_list[0]
    call remove(l:d_list, 0)
    let l:sub_path1 = ""
    let l:sub_path2 = ""

    for l:sub_path in l:d_list
      if (l:sub_path1 == "")
        let l:sub_path1 = l:sub_path
      endif
      if (l:sub_path2 == "")
        let l:sub_path2 = l:sub_path
      endif
      let l:cmd2 = '!tin_url("'
      let l:cmd2 .= l:out_path . l:sub_path
      let l:cmd2 .= '", "'
      let l:cmd2 .= substitute(l:url, 'github.com', 'raw.githubusercontent.com', '')
      let l:cmd2 .= '/master/'
      let l:cmd2 .= l:sub_path
      let l:cmd2 .= '");'
      echom "Cmd2: " . l:cmd2
      silent execute l:cmd2
      if (match(l:sub_path, "autoload/airline/") != -1)
        echo "Sourcing autoload: " . l:sub_path
        execute "source " . l:out_path . l:sub_path
      endif
    endfor

    echo "Sourcing plugin: " . l:sub_path
    execute "source " . l:out_path . l:sub_path1

    " Runtime path
    let &runtimepath.=",/vim/plugin/" . a:name

endfunction

function! CompletePlugin(ArgLead, CmdLine, CursorPos)
  let l:plugin = keys(g:d_plugin)
  let l:res = []
  for l:elt in l:plugin
   if (match(l:elt, a:ArgLead) != -1)
     call add(l:res, l:elt)
   endif
  endfor
  return l:res
endfunction


command! -nargs=1 -complete=customlist,CompletePlugin Plug call LoadPlugin(<q-args>)

" AnsiEscape autocommands
au BufEnter *.a.txt echom "Loading ansiesc" | call LoadPlugin("ansiesc")| set nowrap | echom "I saw an ansi file"
au BufWinEnter *.a.txt AnsiEsc
au ColorScheme * AnsiEsc!


" Use monospace fonts only!
set guifont=14px\ \"Source\ Code\ Pro\"\\,monospace

silent so $VIMRUNTIME/syntax/syntax.vim
colorscheme Darkside


"========== MAP ==========
" As autocmd otherwise CR is interpreted ... 
au VimEnter * map gf gEWvE"fy:call ReadWrapper(@f)<CR>
au VimEnter * map gx gEWvE"fy:call OpenXref(@f)<CR>
au VimEnter * map gs :call DownloadFile()<CR>
au VimEnter * inoremap jk <esc>
au VimEnter * inoremap kj <esc>


"========== OTHERS ==========
" Some are actually not yet supported
set number
set wildmenu
set tabstop=4
set expandtab
set nocompatible
set fileencodings=utf8
set nowrap
set encoding=utf8
set termencoding=utf8
set backspace=indent,eol,start
set wildmode=longest,list,full
set mouse=a
set shiftwidth=4

"========== PLUGGIN ==========



"========== EXPERIMENTAL (not in Vim) ==========
" Read local files
" :bro e local

" Read files from Dropbox
" :bro e dropbox

" Call JavaScript (Note the escape of !)

" If you are editing a JavaScript file:
" :!%

" emscripten API works:
" :!FS.mkdir('/foo')

